taskKey="com.javarush.task.task27.task2712.big22"


Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.

Ресторан(20)

Фикс бага - планшет направляет свой заказ всем известным ему поварам.
Ожидаемое поведение: планшет направляет свой заказ в очередь, свободный повар берет заказы из очереди.

Есть два варианта реализации такого функционала:
1) Каждый планшет хранит ссылку на очередь и толкает в нее новый свой заказ.
2) Планшет толкает свой заказ в Observer, который хранит в себе ссылку на очередь. Observer заносит заказ в очередь.

Мы пойдем по второму пути.
1. Создай класс OrderManager, который будет Observer для планшетов.
2. В классе OrderManager создай поле orderQueue типа LinkedBlockingQueue<Order>. В него складывай все заказы, поступающие в метод update.
3. Класс Cook теперь - НЕ Observer.
4. В классе Cook создай метод void startCookingOrder(Order order), в который перенеси логику из метода update.
5. Удали метод update из класса Cook.
6. В методе main расставь зависимость Observer-Observable в связи с вышеперечисленными изменениями.

Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet< tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!

Ресторан(18)

Сейчас у нас один планшет и 1 повар.
Давай создадим несколько планшетов, которые будут рандомно генерировать заказы, и сделаем два повара.

1. В классе Restaurant создай ПРИВАТНУЮ статическую константу int ORDER_CREATING_INTERVAL = 100.

2. В отдельном классе создай таск(Runnable) RandomOrderGeneratorTask. Этот таск должен:
2.1. Хранить список всех планшетов
2.2. Используя Math.random выбирать случайный планшет.
2.3. У RandomOrderGeneratorTask должен быть только один единственный метод.
2.4. Генерировать случайный заказ каждые ORDER_CREATING_INTERVAL миллисекунд для планшета из п.2.2. (не печатай стек-трейс)
Сейчас заказ создается в методе createOrder в классе Tablet.
В классе Tablet создай метод void createTestOrder() с похожей функциональностью,
который будет случайным образом генерировать заказ со случайными блюдами не общаясь с реальным человеком.
Все необходимые данные передай в конструкторе.
Подсказка:
а) создай класс TestOrder - наследник Order - в пакете родителя.
б) в классе Order создай protected метод initDishes(), в котором инициализируй dishes. Вызови этот метод в конструкторе
в) сделай поле dishes protected
г) переопредели initDishes в классе-наследнике TestOrder. Сделай инициализацию случайным набором блюд.
д) вместо создания объекта Order в методе createTestOrder() класса Tablet, создавай объект класса TestOrder.
Весь другой функционал метода createTestOrder оставь прежним

3. Отрефакторь методы createTestOrder() и createOrder(): в одном из методов выдели код, который повторяется в обоих методах,
и нажми Ctrl+Alt+M, введи любое имя метода и нажми ОК. IDEA предложит заменить этот код во втором методе, подтверди.



Ресторан(16)

Реализуем первый пункт статистики - какую сумму заработали на рекламе, сгруппировать по дням.

1. В классе VideoSelectedEventDataRow создай геттер для поля amount.
В классе CookedOrderEventDataRow создай геттер для поля cookName.

2. В StatisticManager создай метод (придумать самостоятельно), который из хранилища достанет все данные,
относящиеся к отображению рекламы, и посчитает общую прибыль за каждый день.
Дополнительно добавь вспомогательный метод get в класс хранилища, чтобы получить доступ к данным.

3. Начнем с логики метода printAdvertisementProfit в классе DirectorTablet.
Используя метод из предыдущего пункта вывести в консоль в убывающем порядке даты и суммы.
Для каждой даты из хранилища событий, для которой есть показанная реклама, должна выводится сумма прибыли за показы рекламы для этой даты.
В конце вывести слово Total и общую сумму.
Пример:
14-May-2013 - 2.50
13-May-2013 - 1.02
12-May-2013 - 543.98
Total - 547.50

4.Реализуем второй пункт статистики - загрузка (рабочее время) повара, сгруппировать по дням.

В StatisticManager создай метод (придумать самостоятельно), который из хранилища достанет все данные,
относящиеся к работе повара, и посчитает общую продолжительность работы для каждого повара отдельно.

5. Реализуем логику метода printCookWorkloading в классе DirectorTablet.
Используя метод из предыдущего пункта вывести в консоль в убывающем порядке даты, имена поваров и время работы в минутах (округлить в большую сторону).
Для каждой даты из хранилища событий, для которой есть запись о работе повара, должна выводится продолжительность работы в минутах для этой даты.
Если повар не работал в какой-то из дней, то с пустыми данными его НЕ выводить (см. 13-May-2013)
Поваров сортировать по имени
Пример:
14-May-2013
Ivanov - 60 min
Petrov - 35 min

13-May-2013
Ivanov - 129 min

12-May-2013
Ivanov - 6 min
Petrov - 5 min


Требования:
1.	В классе VideoSelectedEventDataRow должен быть создан геттер для поля amount.
2.	В классе CookedOrderEventDataRow должен быть создан геттер для поля cookName.
3.	Метод printAdvertisementProfit класса DirectorTablet должен быть реализован в соответствии с условием задачи.
4.	Метод printCookWorkloading класса DirectorTablet должен быть реализован в соответствии с условием задачи.


Ресторан(15)

Давай подумаем что нужно сделать, чтобы директор мог посмотреть:
1) какую сумму заработали на рекламе, сгруппировать по дням;
2) загрузка (рабочее время) повара, сгруппировать по дням;
3) список активных роликов и оставшееся количество показов по каждому;
4) список неактивных роликов (с оставшемся количеством показов равным нулю).

Для каждого пункта добавим соответствующий метод в StatisticManager.
Директор будет вызывать метод, StatisticManager будет делать различные подсчеты.
Но директор должен из какого-то места вызвать эти методы. Дадим ему планшет, но с другим ПО.
Для этого создадим класс DirectorTablet, в котором будут дружелюбный интерфейс и возможность обращения к статистике.

1. В корне задачи-проекта создай класс DirectorTablet.

2. В классе DirectorTablet создай четыре void метода:
printAdvertisementProfit(), printCookWorkloading(), printActiveVideoSet(), printArchivedVideoSet()
Они соответствуют перечисленным четырем пунктам.

3. Чтобы можно было проверить результат, добавим в метод main создание директорского планшета и вывод статистики
с помощью методов перечисленных выше.

Нам понадобятся еще некоторые методы.
4. В EventDataRow создай методы:
Date getDate(), реализация которого вернет дату создания записи
int getTime(), реализация которого вернет время - продолжительность

5. В StatisticManager void register(Cook cook), который зарегистрирует полученного повара.
Создай в классе StatisticManager множество (Set) поваров (cooks) и добавь в него повара.

6. Реализуй необходимые геттеры у классов CookedOrderEventDataRow, NoAvailableVideoEventDataRow и VideoSelectedEventDataRow.



Ресторан(14)

1. Внутри StatisticStorage создай метод void put(EventDataRow data).

2. Чтобы методом put(EventDataRow data) добавить объект data в данные карты, нужен тип события - EventType.
Будет правильно, если событие будет хранить в себе свой тип. Поэтому:
2.1. В интерфейс EventDataRow добавь метод EventType getType()
2.2. Реализуй этот метод в каждом классе-событии: CookedOrderEventDataRow, NoAvailableVideoEventDataRow, VideoSelectedEventDataRow

3. Сделай так, чтобы к методу void put(EventDataRow data) нельзя было получить доступ за пределами класса StatisticManager.
Воспользуйся особенностями вложенных классов.

Теперь остается расставить вызовы StatisticManager в те места, которые генерируют события.

4. Зарегистрируй событие для повара во время приготовления еды.
Добавь геттер для поля dishes в класс Order, используйте его при создании события.

5. Зарегистрируй событие "видео выбрано" перед отображением рекламы пользователю.

6. Метод register с одним параметром типа EventDataRow должен регистрировать полученное событие в statisticStorage.



Ресторан(13)

Вернемся к методу register в классе StatisticManager. Он должен регистрировать события в хранилище.
Создадим хранилище :)
Хранилище связано 1 к 1 с менеджером, т.е. один менеджер и одно хранилище на приложение.
К хранилищу может доступиться только StatisticManager. Поэтому...
Из вышеперечисленного следует, что хранилище должно быть приватным иннер классом.
Назовем его StatisticStorage.

1. Внутри класса StatisticManager создать приватный иннер класс StatisticStorage.

2. Чтобы менеджер мог получить доступ к хранилищу, нужно в классе StatisticManager создать поле statisticStorage типа StatisticStorage.
Инициализируй его экземпляром класса.

3. StatisticStorage будет хранить данные внутри себя в виде мапы/словаря storage.
Связь StatisticStorage и Map должна быть has-a
Типы для мапы - <EventType, List<EventDataRow>>

4. В конструкторе StatisticStorage инициализируй хранилище данными по-умолчанию:
например используя цикл, для каждого EventType добавь new ArrayList<EventDataRow>()



Ресторан(12)

У нас выделяются несколько событий:
*повар приготовил заказ
*выбрали набор видео-роликов для заказа
*нет ни одного видео-ролика, который можно показать во время приготовления заказа

Это постоянные данные, поэтому для их хранения подходит энам.

1. В пакете event создай enum EventType {COOKED_ORDER, SELECTED_VIDEOS, NO_AVAILABLE_VIDEO}

2. В пакете event создай три класса, соответствующих значениям энама. Они будут(должны) представлять собой события.
Мы будем регистрировать их экземпляры в хранилище.
Имена классов с параметрами для конструкторов:
2.1. CookedOrderEventDataRow(String tabletName, String cookName, int cookingTimeSeconds, List<Dish> cookingDishs)
где - tabletName - имя планшета
cookName - имя повара
cookingTimeSeconds - время приготовления заказа в секундах
cookingDishs - список блюд для приготовления
2.2. NoAvailableVideoEventDataRow(int totalDuration)
totalDuration - время приготовления заказа в секундах
2.3. VideoSelectedEventDataRow(List<Advertisement> optimalVideoSet, long amount, int totalDuration)
optimalVideoSet - список видео-роликов, отобранных для показа
amount - сумма денег в копейках
totalDuration - общая продолжительность показа отобранных рекламных роликов
3. В классы, созданные в п.2., добавьте поле Date currentDate, которое проинициализируй в конструкторе текущей датой.



Ресторан(11)

Мы реализовали первые две фичи из трех. Напомню, первой была автоматизация приготовления заказа,
второй - подбор рекламных роликов, а третья - статистика для директора. Собственно, к ней мы и добрались.

Нам нужно будет реализовать следующую функциональность:
1) подсчет статистики
2) отображение статистики директору

Попробуем определиться с последовательностью действий. Чтобы отображать данные, сначала нужно их откуда-то получить.

Есть два подхода:
ПЕРВЫЙ - применяется, когда сложно получить реальные данные, либо когда другой человек работает над получением данных:
1. захардкодить данные в приложении
2. отобразить хардкоженную статистику
3. сделать получение реальных данных - реальную статистику (интеграция с чужим кодом)

ВТОРОЙ:
1. сделать получение реальных данных - реальную статистику
2. отобразить статистику

Т.к. мы сами реализовываем данную функциональность, и статистика у нас не сложная, то выберем второй подход.
Начнем с получения реальных данных - реальной статистики.

Идея такая:
Есть хранилище событий.
Когда у нас случается событие, то мы будем регистрировать это событие в хранилище.
На запрос директора мы будем фильтровать события из хранилища, вычислять необходимые данные и отображать их.

Для начала нам нужно несколько классов.
1. Создадим пакет statistic, в котором создадим класс StatisticManager. С его помощью будем регистрировать события в хранилище.
2. У нас должно быть одно хранилище с одной точкой входа. Поэтому сделаем StatisticManager синглтоном.
3. Внутри пакета statistic создадим вложенный пакет event, в котором будут храниться классы, связанные с событиями.
4. Создадим в пакете event интерфейс EventDataRow. На данный момент он является интерфейсом-маркером,
т.к. не содержит методов, и по нему мы определяем, является ли переданный объект событием или нет.
5. В StatisticManager создадим публичный метод void register(EventDataRow data), который будет регистрировать событие в хранилище.
Мы вернемся к реализации позднее.



